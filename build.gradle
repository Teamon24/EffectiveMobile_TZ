import org.apache.commons.lang3.tuple.Pair

import java.nio.file.Files
import java.nio.file.Path
import java.util.regex.Matcher
import java.util.regex.Pattern

buildscript {
    dependencies {
        classpath 'commons-io:commons-io:2.6'
    }
}

plugins {
    id 'java'
    id 'application'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.springdoc.openapi-gradle-plugin' version '1.8.0'
    id 'org.openapi.generator' version '7.2.0'
}

group 'org.effective-mobile'
version '1.0'

ext {
    customPropPrefix = 'custom'
    defaultProfile = 'default'
    rootPackage = 'org.effective_mobile.task_management_system'
    appEntrypoint = "${rootPackage}.TaskManagementSystemApp"

    profile                 = projectPropOrElse(customProp('profile'), 'dev')
    openApiGeneratingToWait = projectPropOrElse(customProp('timeToWait'), '120')
    apiModuleJdk            = projectPropOrElse(customProp('apiModuleJdk'), '8')
    entrypoint              = projectPropOrElse(customProp('entrypoint'), appEntrypoint)
    apiModuleMaven          = projectPropOrThrow(customProp('mvnHome'))

    apiDir = 'api'
    apiDocsFilename = "$name-$apiDir-$version${defaultProfile == profile ? '' : '-' + profile}.json"

    paths = [ src     : slpath("$rootDir", 'src') ]
    paths.rootPath         = "$rootDir"
    paths.resources        = slpath(paths.src            , 'main', 'resources')
    paths.api              = slpath(paths.src            , apiDir)
    paths.apiFilesToCopy   = slpath(paths.rootPath       , 'docs')
    paths.apiDocsFile      = slpath(paths.apiFilesToCopy , apiDocsFilename)
    paths.apiGitIgnoreFile = slpath(paths.apiFilesToCopy , 'open.api.gitignore')
    paths.deploy           = slpath(paths.rootPath       , 'deploy')
    paths.build            = slpath(paths.rootPath       , 'build', 'libs')

    paths.jvm              = slpath('/usr' , 'lib', 'jvm')
    paths.jdk              = slpath(paths.jvm, "java-$apiModuleJdk-openjdk-amd64")
    paths.javac            = slpath(paths.jdk, 'bin', 'javac')

    paths.appPropsFile  = appPropsName -> slpath(paths.resources, "${appPropsName}.properties")

    profiles = getProfilesFromProps(paths.resources)
    printProjectProperties()

    openApiProfile = 'open-api-generation'
    openApiGenerationProps = profiles[openApiProfile]

    port = openApiGenerationProps.get('server.port')
    address = openApiGenerationProps.get('server.address')
    apiSpecUrl = "http://$address:$port/v3/api-docs"

    jar = [
            name    : "$project.name-${version}.jar",
            build   : paths.build,
            deploy  : paths.deploy
    ]

    api = [
            artifactId: "$project.name-$apiDir",
            version   : version
    ]

    api.jar = "${api.artifactId}-${api.version}.jar"
}

private String customProp(String property) {
    return "${customPropPrefix}.${property}" as String
}

java {
    sourceCompatibility = '17'
    targetCompatibility = '17'
}

application {
    mainClass.set(entrypoint)  }

repositories {
    mavenCentral() }


sourceSets {
    generated {
        java {
            srcDirs = [slpath("$buildDir", 'generated', 'sources', 'annotationProcessor', 'java', 'main')]
        }
    }
}

dependencies {
    // OPEN-API-МОДУЛЬ.
    implementation files(slpath(paths.api, 'target', api.jar))

    // LOMBOK -----------------------------------------------------------------
    def lombok_v = '1.18.30'
    def querydsl_v = '5.0.0:jakarta'
    def jakarta_v = '3.1.0'
    def junit_v = '5.10.1'
    compileOnly "org.projectlombok:lombok:${lombok_v}"
    annotationProcessor "org.projectlombok:lombok:${lombok_v}"
    testCompileOnly "org.projectlombok:lombok:${lombok_v}"
    testAnnotationProcessor "org.projectlombok:lombok:${lombok_v}"

    // SPRING ----------------------------------------------------------------
    configurations {
        all {
            exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
            exclude group: 'org.springframework.boot', module: 'logback-classic'
        }
    }
    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-cache'
    implementation 'com.github.ben-manes.caffeine:caffeine:3.1.8'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-log4j2'
    implementation 'com.lmax:disruptor:3.4.4'

    // JWT -------------------------------------------------------------------
    implementation 'com.auth0:java-jwt:4.4.0'

    // QUERYDSL --------------------------------------------------------------
    implementation "com.querydsl:querydsl-jpa:${querydsl_v}"
    annotationProcessor "com.querydsl:querydsl-apt:${querydsl_v}"

    implementation "jakarta.persistence:jakarta.persistence-api:${jakarta_v}"
    annotationProcessor "jakarta.persistence:jakarta.persistence-api:${jakarta_v}"

    // MISC -----------------------------------------------------------------
    implementation 'org.postgresql:postgresql:42.5.4'
    implementation 'com.google.guava:guava:31.0.1-jre'
    implementation 'org.apache.commons:commons-text:1.9'
    implementation 'javax.xml.bind:jaxb-api:2.3.1'

    // DOCUMENTING----------------------------------------------------------
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.3'

    // TESTS --------------------------------------------------------------
    implementation 'net.datafaker:datafaker:2.0.2'
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junit_v}"
    testImplementation "org.junit.jupiter:junit-jupiter-api:${junit_v}"
    testImplementation "org.junit.jupiter:junit-jupiter-params:${junit_v}"

    testRuntimeOnly 'com.h2database:h2'
    runtimeOnly 'com.h2database:h2'

    testImplementation 'org.testcontainers:junit-jupiter:1.17.5'
    testImplementation 'org.testcontainers:testcontainers:1.17.5'
    testImplementation 'org.testcontainers:postgresql:1.17.5'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'

}

test {
    useJUnitPlatform()
}

task copyJar(type: Copy) {
    from slpath(jar.build, jar.name)
    into jar.deploy
}

task deleteJar() {
    file(slpath(jar.deploy, jar.name)).delete()
}

bootJar {
    archiveFileName = jar.name
}

task cleanApiModule {
    doLast {
        if (file(paths.api).exists()) {
            println "cleanApiModule: cleaning up api module (${paths.api})"
            Files.walk(Path.of(paths.api))
                    .filter(path -> path.toString() != paths.api)
                    .sorted(Comparator.reverseOrder())
                    .map(Path::toFile)
                    .forEach(File::delete)
        }
    }
}

task deleteApiSpecification {
    doLast {
        def file = file(paths.apiDocsFile)
        file.exists() ? file.delete() : false
    }
}

generateOpenApiDocs {
    mainClassName = entrypoint
    doFirst {
        println "generateOpenApiDocs: entrypoint='$entrypoint'"
    }
}

openApi {
    apiDocsUrl = apiSpecUrl
    outputDir = file(paths.apiFilesToCopy)
    outputFileName = apiDocsFilename
    waitTimeInSeconds = Integer.valueOf(openApiGeneratingToWait)

    customBootRun {
        args = ["--spring.profiles.active=$openApiProfile"]
    }
}

openApiValidate {
    inputSpec = paths.apiDocsFile
    recommend = true
}

openApiMeta {
    generatorName = "Jim"
    packageName = rootPackage
}

//Генерация API
openApiGenerate {
    generatorName = 'spring'
    inputSpec = paths.apiDocsFile
    outputDir = paths.api
    apiPackage = rootPackage + '.api'
    modelPackage = rootPackage + '.model'

    configOptions = [
            groupId: "$project.group",
            artifactId: "${api.artifactId}",
            artifactVersion: "${api.version}",
            name: "$project.name-api",
            interfaceOnly: 'true',
            useResponseEntity: 'false',
            skipDefaultInterface: 'true'
    ]

    if (Integer.valueOf(apiModuleJdk) == 8) {
        configOptions.put('java8', 'true')
    } else {
        configOptions.put('useSpringBoot3', 'true')
        configOptions.put('useJakartaEe'  , 'true')
    }
}

//Мультимодульный проект
//https://stackoverflow.com/questions/65504256/how-to-generate-compile-jar-and-depend-on-a-gradle-module
//https://andresalmiray.com/multi-module-project-builds-with-maven-and-gradle/
task compileApiModule(type: Exec) {
    def forking = '-Dmaven.compiler.fork=true'
    def executing = "-Dmaven.compiler.executable=${paths.javac}"
    def commandLineArray = [
            "$apiModuleMaven",
            '-f', "$paths.api/",
            'clean', 'compile', 'package', '-e',
            forking,
            executing
    ]
    doFirst {
        println "compileApiModule: command='${String.join(" ", commandLineArray)}'"
    }
    workingDir "$paths.api"
    commandLine commandLineArray
}

task copyOpenApiGitIgnore () {
    doLast {
        file(slpath(paths.api, '.openapi-generator-ignore')).delete()
        copy {
            from(file(paths.apiGitIgnoreFile))
            into(file(paths.api))
        }
    }
}

def getProfilesFromProps(path) {
    def regex = "application(.*)\\.properties"
    def appPropsPattern = Pattern.compile(regex)
    def profiles = new HashMap<String, Properties>()

    fileTree(dir: path)
            .findAll()
            .stream()
            .map(it -> it.name)
            .filter(it -> it.matches(regex))
            .map(it -> {
                Matcher m1 = appPropsPattern.matcher(it)
                m1.find()
                return m1.group(1)
            })
            .forEach(propsFilePostfix -> {
                String replaced = propsFilePostfix.replaceFirst('-', '');
                String profile = replaced.isBlank() ? defaultProfile : replaced
                profiles[profile] = readProps('application' + propsFilePostfix)
            })
    return profiles
}

forkedSpringBootRun {
    doNotTrackState('See https://github.com/springdoc/springdoc-openapi-gradle-plugin/issues/102')
}

def readProps(appPropsName) {
    String appProps = paths.appPropsFile("${appPropsName}")
    File appPropsFile = file(appProps)
    try {
        FileInputStream configFileReader = new FileInputStream(appPropsFile);
        def properties = new Properties()
        try {
            properties.load(configFileReader);
            configFileReader.close();
            return properties
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    } catch (FileNotFoundException e) {
        System.out.println(e.getMessage());
        throw new RuntimeException();
    }
}

def projectPropOrElse(String propName, defaultValue) {
    return project.properties.getOrDefault(propName, defaultValue)
}

def projectPropOrThrow(propName) {
    def propValue = project.properties.get(propName)
    if (propName == null) throw new RuntimeException("$propName is not defined as gradle project property.")
    return propValue.toString()
}

void printProjectProperties() {
    String max = project.properties.keySet().stream().max(Comparator.comparing(String::length)).get();
    project.properties
            .entrySet()
            .stream()
            .filter(p -> p.getKey().startsWith(customPropPrefix))
            .filter(p -> !Objects.equals(p.getKey(), 'properties'))
            .sorted(Comparator.comparing(Map.Entry::getKey))
            .map(entry -> Pair.of(entry, max.length() - entry.getKey().length()))
            .forEach(entryAndDiff -> {
                Integer diff = entryAndDiff.getRight();
                var entry = entryAndDiff.getLeft();
                System.out.println('%s = %s'.formatted(entry.getKey() + ' '.repeat(diff), entry.getValue()))
            })
}

static def slpath(String... pathParts) {
    String.join(File.separator, pathParts)
}
